---
import { Picture } from 'astro:assets'
import type { CollectionEntry } from 'astro:content'
import FormattedDate from '@components/FormattedDate.astro'
import { POST_IMAGE_HEIGHT, POST_IMAGE_WIDTH } from '@constants/posts'
import Layout from '@layouts/Layout.astro'
import { getReadTimeText } from '@utils/readTime'

type Props = CollectionEntry<'posts'>['data'] & {
  content: string
}

const { title, description, publicationDate, updatedDate, heroImage, content } =
  Astro.props
---

<Layout
  metadata={{
    title,
    description,
    date: publicationDate.toISOString(),
    image: heroImage ? heroImage.src : undefined,
  }}
>
  <article class="post">
    {
      heroImage && (
        <Picture
          class="post__hero-image"
          src={heroImage}
          alt={description || ''}
          formats={['avif', 'webp', 'png']}
          width={POST_IMAGE_WIDTH}
          height={POST_IMAGE_HEIGHT}
          widths={[360, 540, 720, 960, 1920]}
          sizes="(min-width: 960px) 960px, 100vw"
          loading="eager"
          decoding="sync"
          fetchpriority="high"
        />
      )
    }
    <div class="post__content">
      <h1 class="post__title">{title}</h1>
      <ul class="post__details">
        <li>
          ðŸ“… Fecha: <FormattedDate date={publicationDate} />
        </li>
        {
          updatedDate && (
            <li>
              ðŸ•’ Ãšltima actualizaciÃ³n: <FormattedDate date={updatedDate} />
            </li>
          )
        }
        <li>
          ðŸ“– Tiempo de lectura: {getReadTimeText(content)}
        </li>
      </ul>

      <slot />
    </div>
  </article>
</Layout>

<script>
  const imagesToObserve = document.querySelectorAll('.post img')

  if (imagesToObserve.length > 0) {
    const loadZoom = async () => {
      try {
        const mediumZoom = (await import('medium-zoom')).default

        mediumZoom('.post img', {
          margin: 40,
          background: 'rgba(0,0,0,0.8)',
          scrollOffset: 40,
        })
      } catch (error) {
        console.error('Error al cargar medium-zoom:', error)
      }
    }

    const observer = new IntersectionObserver(
      (entries, observer) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue
          loadZoom()
          observer.disconnect()
          break
        }
      },
      {
        rootMargin: '200px 0px',
        threshold: 0.1,
      },
    )

    imagesToObserve.forEach((image) => observer.observe(image))
  }
</script>

<style>
  .post {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    background-color: var(--color-background);
    max-width: 60rem;
    margin-left: auto;
    margin-right: auto;
    padding-bottom: 3rem;
    box-shadow: var(--box-shadow);
  }

  .post__content {
    padding-left: 2rem;
    padding-right: 2rem;
    border-radius: 0.5rem;
  }

  .post__hero-image {
    width: 100%;
    height: auto;
    object-fit: cover;
  }

  .post__title {
    font-size: 3rem;
    margin-top: 1rem;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
  }

  @media screen and (max-width: 40rem) {
    .post__title {
      font-size: 2rem;
    }
  }

  .post__details {
    list-style: none;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 1rem;
    padding: 0;
    margin-top: 0;
    margin-bottom: 0;
    font-size: 1.25rem;
    padding-bottom: 1rem;
    border-bottom: 0.2rem solid var(--color-text);
  }
</style>
